# -*- coding: utf-8 -*-
"""Untitled44.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iSHQu_4X0Fc1MCEcGnaFk92j0sDNcKG0
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile prompts.py
# # prompts.py
# 
# SYSTEM_PROMPT = """
# You are TalentScout's AI Hiring Assistant, designed to help with the initial screening of tech candidates.
# Your job is to:
# 1. Greet candidates professionally and explain your purpose
# 2. Collect essential candidate information
# 3. Ask about their technical skills and experience
# 4. Generate relevant technical questions based on their declared tech stack
# 5. Maintain a friendly, professional tone throughout the conversation
# 6. End the conversation gracefully when the candidate indicates they're finished
# 
# Follow these guidelines:
# - Collect information systematically: name, email, phone, experience, desired position, location, and tech stack
# - Generate 3-5 technical questions specific to each technology the candidate mentions
# - Keep the conversation focused on the screening process
# - If the candidate says "goodbye", "exit", or similar, thank them and end the conversation
# - If you don't understand an input, politely ask for clarification
# - Do not ask for sensitive personal information beyond standard contact details
# - Maintain context throughout the conversation
# """
# 
# INITIAL_GREETING = """
# Hello! I'm TalentScout's AI Hiring Assistant. I'm here to help with your initial screening for technical positions.
# 
# I'll need to collect some basic information from you and ask a few questions about your technical background. This will help us match you with appropriate positions.
# 
# Could you please start by telling me your full name?
# """
# 
# INFORMATION_COLLECTION_PROMPTS = {
#     "name": "Could you please tell me your full name?",
#     "email": "Great, {name}! What's your email address where we can contact you?",
#     "phone": "And what's the best phone number to reach you?",
#     "experience": "How many years of experience do you have in the tech industry?",
#     "position": "What position(s) are you interested in applying for?",
#     "location": "What is your current location? (City/State/Country)",
#     "tech_stack": "Please list the technologies, programming languages, frameworks, and tools you're proficient in."
# }
# 
# TECH_QUESTION_GENERATION_PROMPT = """
# Based on the candidate's tech stack ({tech_stack}), generate 3-5 appropriate technical questions to assess their proficiency.
# The questions should:
# - Range from foundational to advanced concepts
# - Include at least one problem-solving scenario
# - Be relevant to the position they're applying for ({position})
# - Be specific to each technology mentioned, not generic
# - Be clear and concise
# """
# 
# CONVERSATION_END_PROMPT = """
# Thank you for your time today, {name}! We've collected your information and assessed your technical background.
# 
# Our recruitment team will review your responses and get back to you at {email} if there's a potential match with our current openings.
# 
# Is there anything else you'd like to know before we conclude this conversation?
# """
# 
# FALLBACK_RESPONSES = [
#     "I'm sorry, I didn't quite understand that. Could you please rephrase?",
#     "I'm having trouble following. Could you clarify what you mean?",
#     "Could you please provide more details so I can better assist you?",
#     "I want to make sure I understand correctly. Could you explain that differently?"
# ]

# Commented out IPython magic to ensure Python compatibility.
# %%writefile chatbot.py
# # chatbot.py
# import os
# import openai
# from dotenv import load_dotenv
# import random
# from prompts import (
#     SYSTEM_PROMPT,
#     INITIAL_GREETING,
#     INFORMATION_COLLECTION_PROMPTS,
#     TECH_QUESTION_GENERATION_PROMPT,
#     CONVERSATION_END_PROMPT,
#     FALLBACK_RESPONSES
# )
# 
# # Load environment variables
# load_dotenv()
# openai.api_key = os.getenv("OPENAI_API_KEY")
# 
# class TalentScoutChatbot:
#     def __init__(self):
#         self.conversation_history = []
#         self.candidate_info = {
#             "name": None,
#             "email": None,
#             "phone": None,
#             "experience": None,
#             "position": None,
#             "location": None,
#             "tech_stack": None,
#             "technical_questions": [],
#             "question_index": 0
#         }
#         self.current_state = "greeting"
#         self.states = [
#             "greeting", "get_name", "get_email", "get_phone",
#             "get_experience", "get_position", "get_location",
#             "get_tech_stack", "generate_questions", "ask_questions",
#             "conclude"
#         ]
# 
#         # Initialize with system prompt
#         self.add_to_history({"role": "system", "content": SYSTEM_PROMPT})
# 
#     def add_to_history(self, message):
#         """Add a message to the conversation history."""
#         self.conversation_history.append(message)
# 
#     def generate_response(self, user_input):
#         """Generate a response based on the current state and user input."""
#         # Check for exit keywords
#         if self._is_exit_request(user_input):
#             return self._generate_exit_message()
# 
#         # Process user input based on current state
#         self.add_to_history({"role": "user", "content": user_input})
# 
#         # Update candidate info based on current state
#         self._update_candidate_info(user_input)
# 
#         # Determine next state and generate appropriate response
#         response = self._get_next_response()
# 
#         self.add_to_history({"role": "assistant", "content": response})
#         return response
# 
#     def _is_exit_request(self, text):
#         """Check if the user wants to exit the conversation."""
#         exit_keywords = ["goodbye", "exit", "quit", "bye", "end", "stop"]
#         return any(keyword in text.lower() for keyword in exit_keywords)
# 
#     def _generate_exit_message(self):
#         """Generate a goodbye message."""
#         name = self.candidate_info["name"] or "there"
#         email = self.candidate_info["email"] or "your provided contact information"
#         return CONVERSATION_END_PROMPT.format(name=name, email=email)
# 
#     def _update_candidate_info(self, user_input):
#         """Update candidate information based on current state and user input."""
#         if self.current_state == "get_name":
#             self.candidate_info["name"] = user_input
#         elif self.current_state == "get_email":
#             self.candidate_info["email"] = user_input
#         elif self.current_state == "get_phone":
#             self.candidate_info["phone"] = user_input
#         elif self.current_state == "get_experience":
#             self.candidate_info["experience"] = user_input
#         elif self.current_state == "get_position":
#             self.candidate_info["position"] = user_input
#         elif self.current_state == "get_location":
#             self.candidate_info["location"] = user_input
#         elif self.current_state == "get_tech_stack":
#             self.candidate_info["tech_stack"] = user_input
# 
#     def _get_next_state(self):
#         """Determine the next state in the conversation flow."""
#         current_index = self.states.index(self.current_state)
#         next_index = min(current_index + 1, len(self.states) - 1)
#         return self.states[next_index]
# 
#     def _get_next_response(self):
#         """Generate the next response based on the current state."""
#         # Move to the next state
#         next_state = self._get_next_state()
# 
#         if self.current_state == "greeting":
#             self.current_state = "get_name"
#             return INITIAL_GREETING
# 
#         elif self.current_state == "get_name":
#             self.current_state = "get_email"
#             return INFORMATION_COLLECTION_PROMPTS["email"].format(name=self.candidate_info["name"])
# 
#         elif self.current_state == "get_email":
#             self.current_state = "get_phone"
#             return INFORMATION_COLLECTION_PROMPTS["phone"]
# 
#         elif self.current_state == "get_phone":
#             self.current_state = "get_experience"
#             return INFORMATION_COLLECTION_PROMPTS["experience"]
# 
#         elif self.current_state == "get_experience":
#             self.current_state = "get_position"
#             return INFORMATION_COLLECTION_PROMPTS["position"]
# 
#         elif self.current_state == "get_position":
#             self.current_state = "get_location"
#             return INFORMATION_COLLECTION_PROMPTS["location"]
# 
#         elif self.current_state == "get_location":
#             self.current_state = "get_tech_stack"
#             return INFORMATION_COLLECTION_PROMPTS["tech_stack"]
# 
#         elif self.current_state == "get_tech_stack":
#             self.current_state = "generate_questions"
#             # Generate technical questions
#             return self._generate_technical_questions()
# 
#         elif self.current_state == "generate_questions":
#             self.current_state = "ask_questions"
#             # Start asking the first question
#             return self._ask_next_question()
# 
#         elif self.current_state == "ask_questions":
#             self.candidate_info["question_index"] += 1
#             # Check if we've asked all questions
#             if self.candidate_info["question_index"] >= len(self.candidate_info["technical_questions"]):
#                 self.current_state = "conclude"
#                 return self._generate_conclusion()
#             else:
#                 return self._ask_next_question()
# 
#         elif self.current_state == "conclude":
#             return self._generate_exit_message()
# 
#         else:
#             # Fallback
#             return random.choice(FALLBACK_RESPONSES)
# 
#     def _generate_technical_questions(self):
#         """Generate technical questions based on the candidate's tech stack."""
#         prompt = TECH_QUESTION_GENERATION_PROMPT.format(
#             tech_stack=self.candidate_info["tech_stack"],
#             position=self.candidate_info["position"]
#         )
# 
#         try:
#             response = openai.ChatCompletion.create(
#                 model="gpt-4",  # Or another appropriate model
#                 messages=[
#                     {"role": "system", "content": SYSTEM_PROMPT},
#                     {"role": "user", "content": prompt}
#                 ],
#                 temperature=0.7,
#                 max_tokens=1000
#             )
# 
#             questions = response.choices[0].message.content.strip().split('\n')
#             # Filter out empty lines and numbering
#             questions = [q.strip() for q in questions if q.strip()]
#             # Remove numbering if present (e.g., "1. ", "- ", etc.)
#             questions = [q.split('. ', 1)[-1] if '. ' in q[:4] else q for q in questions]
#             questions = [q[2:] if q.startswith('- ') else q for q in questions]
# 
#             self.candidate_info["technical_questions"] = questions
# 
#             return f"Thank you for sharing your tech stack. I'd like to ask you a few technical questions to better understand your expertise.\n\nFirst question: {questions[0]}"
# 
#         except Exception as e:
#             print(f"Error generating questions: {e}")
#             return "I'd like to ask you some technical questions about your skills. Let's start with: What are some challenging projects you've worked on using your primary technical skills?"
# 
#     def _ask_next_question(self):
#         """Ask the next technical question."""
#         index = self.candidate_info["question_index"]
#         questions = self.candidate_info["technical_questions"]
# 
#         if index < len(questions):
#             return f"Question {index + 1}: {questions[index]}"
#         else:
#             self.current_state = "conclude"
#             return self._generate_conclusion()
# 
#     def _generate_conclusion(self):
#         """Generate a conclusion for the conversation."""
#         name = self.candidate_info["name"] or "there"
#         email = self.candidate_info["email"] or "your provided contact information"
# 
#         conclusion = f"""
# Thank you, {name}, for taking the time to chat with me today!
# 
# I've collected the following information:
# - Name: {self.candidate_info['name']}
# - Email: {self.candidate_info['email']}
# - Phone: {self.candidate_info['phone']}
# - Experience: {self.candidate_info['experience']}
# - Desired Position: {self.candidate_info['position']}
# - Location: {self.candidate_info['location']}
# - Tech Stack: {self.candidate_info['tech_stack']}
# 
# Our recruitment team will review your information and technical responses. If there's a good match with our current openings, someone will reach out to you at {email} soon.
# 
# Is there anything else you'd like to add before we conclude this conversation?
# """
#         return conclusion
# 
#     def get_state(self):
#         """Get the current state of the conversation."""
#         return self.current_state
# 
#     def get_candidate_info(self):
#         """Get the collected candidate information."""
#         return self.candidate_info

# Commented out IPython magic to ensure Python compatibility.
# %%writefile utils.py
# # utils.py
# import re
# import json
# import os
# from datetime import datetime
# 
# def validate_email(email):
#     """Validate email format."""
#     pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
#     return bool(re.match(pattern, email))
# 
# def validate_phone(phone):
#     """Validate phone number format."""
#     # Remove common separators
#     cleaned = re.sub(r'[\s\-\(\)\.]', '', phone)
#     # Check if result is numeric and reasonable length
#     return cleaned.isdigit() and 7 <= len(cleaned) <= 15
# 
# def save_candidate_data(candidate_info):
#     """Save candidate information to a JSON file."""
#     # Create data directory if it doesn't exist
#     if not os.path.exists('data'):
#         os.makedirs('data')
# 
#     # Generate a unique filename using timestamp and name
#     timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
#     name = candidate_info.get("name", "unknown").lower().replace(" ", "_")
#     filename = f"data/candidate_{name}_{timestamp}.json"
# 
#     # Save to file
#     with open(filename, 'w') as f:
#         json.dump(candidate_info, f, indent=4)
# 
#     return filename
# 
# def extract_technologies(tech_stack_text):
#     """Extract and categorize technologies from the candidate's tech stack."""
#     # Common categories and their keywords
#     categories = {
#         "programming_languages": [
#             "python", "java", "javascript", "typescript", "c++", "c#", "ruby",
#             "php", "swift", "kotlin", "go", "rust", "scala", "perl"
#         ],
#         "frontend": [
#             "react", "angular", "vue", "svelte", "html", "css", "bootstrap",
#             "tailwind", "sass", "less", "jquery"
#         ],
#         "backend": [
#             "node", "express", "django", "flask", "spring", "laravel", "rails",
#             "fastapi", "asp.net", "symfony"
#         ],
#         "databases": [
#             "sql", "mysql", "postgresql", "mongodb", "sqlite", "oracle",
#             "cassandra", "redis", "elasticsearch", "dynamodb", "mariadb"
#         ],
#         "devops": [
#             "docker", "kubernetes", "aws", "azure", "gcp", "jenkins", "gitlab",
#             "github", "terraform", "ansible", "ci/cd", "linux"
#         ],
#         "mobile": [
#             "android", "ios", "react native", "flutter", "xamarin", "swift",
#             "kotlin", "objective-c"
#         ],
#         "ai_ml": [
#             "tensorflow", "pytorch", "scikit-learn", "pandas", "numpy",
#             "opencv", "nlp", "computer vision", "machine learning"
#         ]
#     }
# 
#     result = {category: [] for category in categories}
# 
#     # Convert to lowercase for case-insensitive matching
#     text_lower = tech_stack_text.lower()
# 
#     # Extract technologies for each category
#     for category, keywords in categories.items():
#         for keyword in keywords:
#             if keyword in text_lower:
#                 # Check if it's a whole word match
#                 pattern = r'\b' + re.escape(keyword) + r'\b'
#                 if re.search(pattern, text_lower):
#                     result[category].append(keyword)
# 
#     # Remove empty categories
#     result = {k: v for k, v in result.items() if v}
# 
#     return result

!pip install streamlit openai python-dotenv

code = '''\
import streamlit as st
from chatbot import TalentScoutChatbot
import time
import os
import json
from datetime import datetime
from utils import save_candidate_data

# Set page config
st.set_page_config(
    page_title="TalentScout Hiring Assistant",
    page_icon="💼",  # Suit emoji
    layout="centered"
)

# Custom CSS for styling
st.markdown(
    """
    <style>
        .main {
            background-color: #f5f7f9;
        }
        .stTextInput>div>div>input {
            border-radius: 20px;
        }
        .chat-message {
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 0.75rem;
        }
        .chat-message.user {
            background-color: #e6f3ff;
            border-left: 5px solid #2c88d9;
        }
        .chat-message.bot {
            background-color: #f0f2f5;
            border-left: 5px solid #6c757d;
        }
        .chat-message .avatar {
            min-width: 40px;
        }
        .chat-message .message {
            flex-grow: 1;
        }
        .stButton>button {
            border-radius: 20px;
            padding: 0.5rem 1rem;
            background-color: #2c88d9;
            color: white;
            border: none;
        }
        .stButton>button:hover {
            background-color: #1b5a8a;
        }
    </style>
    """,
    unsafe_allow_html=True
)

# Initialize chatbot in session state if not already initialized
if 'chatbot' not in st.session_state:
    st.session_state.chatbot = TalentScoutChatbot()

if 'messages' not in st.session_state:
    st.session_state.messages = []
    bot_message = st.session_state.chatbot.generate_response("Hi")
    st.session_state.messages.append({"role": "bot", "content": bot_message})

# Track if data has been saved
if 'data_saved' not in st.session_state:
    st.session_state.data_saved = False

# Function to save candidate data
def save_data():
    if not st.session_state.data_saved:
        candidate_info = st.session_state.chatbot.get_candidate_info()

        # Check if we have enough data to save
        if candidate_info['name'] and candidate_info['email']:
            try:
                # Create data directory if it doesn't exist
                if not os.path.exists('data'):
                    os.makedirs('data')

                # Generate a unique filename
                timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
                name = candidate_info.get("name", "unknown").lower().replace(" ", "_")
                filename = f"data/candidate_{name}_{timestamp}.json"

                # Save to file
                with open(filename, 'w') as f:
                    json.dump(candidate_info, f, indent=4)

                st.session_state.data_saved = True
                st.session_state.saved_filename = filename
                return True
            except Exception as e:
                st.error(f"Error saving data: {e}")
                return False
    return False

# App header
st.title("TalentScout Hiring Assistant")
st.subheader("AI-powered candidate screening")

# Display chat messages
for message in st.session_state.messages:
    with st.container():
        if message["role"] == "user":
            st.markdown(f"""
            <div class="chat-message user">
                <div class="avatar">👤</div>  <!-- User icon -->
                <div class="message">{message["content"]}</div>
            </div>
            """, unsafe_allow_html=True)
        else:
            st.markdown(f"""
            <div class="chat-message bot">
                <div class="avatar">🤖</div>  <!-- Robot icon -->
                <div class="message">{message["content"]}</div>
            </div>
            """, unsafe_allow_html=True)

# Chat input with form
with st.form(key="message_form", clear_on_submit=True):
    user_input = st.text_input(
        "Your message:",
        key="user_input",
        placeholder="Type your message here..."
    )
    submit_button = st.form_submit_button("Send")

    if submit_button and user_input.strip():
        st.session_state.messages.append({"role": "user", "content": user_input})

        with st.spinner("Thinking..."):
            bot_response = st.session_state.chatbot.generate_response(user_input)
            time.sleep(0.5)  # Simulate typing delay
            st.session_state.messages.append({"role": "bot", "content": bot_response})

            # Check if conversation is concluding and save data
            current_state = st.session_state.chatbot.get_state()
            if current_state == "conclude":
                save_data()

# Display saved data notification
if st.session_state.get('data_saved', False):
    st.success(f"Candidate data has been saved to {st.session_state.saved_filename}")

    # Show download button for the saved data
    if os.path.exists(st.session_state.saved_filename):
        with open(st.session_state.saved_filename, 'r') as f:
            st.download_button(
                label="Download Candidate Data",
                data=f.read(),
                file_name=os.path.basename(st.session_state.saved_filename),
                mime="application/json"
            )

# Display debug info (optional)
current_state = st.session_state.chatbot.get_state()
if st.checkbox("Show debug info"):
    st.write(f"Current state: {current_state}")
    st.write("Candidate info:")
    st.write(st.session_state.chatbot.get_candidate_info())

    # Add a manual save button in debug mode
    if st.button("Save Data Now"):
        if save_data():
            st.success("Data saved successfully!")
        else:
            st.warning("Not enough data to save or data already saved.")

# Admin section (password protected)
with st.expander("Admin Access"):
    password = st.text_input("Admin Password", type="password")
    if password == "admin123":  # Very simple password, should be more secure in production
        st.success("Admin access granted")

        # List all saved candidate files
        if os.path.exists('data'):
            files = [f for f in os.listdir('data') if f.endswith('.json')]
            if files:
                selected_file = st.selectbox("Select candidate data file", files)

                if selected_file:
                    file_path = os.path.join('data', selected_file)
                    with open(file_path, 'r') as f:
                        candidate_data = json.load(f)
                        st.json(candidate_data)

                        st.download_button(
                            label="Download Selected Data",
                            data=json.dumps(candidate_data, indent=4),
                            file_name=selected_file,
                            mime="application/json"
                        )
            else:
                st.info("No candidate data files found.")
    elif password and password != "":
        st.error("Incorrect password")

# Footer
st.markdown("---")
st.markdown("© 2025 TalentScout - AI Hiring Assistant")
'''

# Write to a file
with open("app.py", "w") as f:
    f.write(code)

print("app.py has been successfully created!")

!streamlit run app.py &>/dev/null &

!ngrok config add-authtoken 2v39O6NY8cYaiZZZpLbtgkSPlfG_6MzrMZ5piXU7SGSwf1ed2

!pip install pyngrok

!pkill -f ngrok

from pyngrok import ngrok

# Start a new session
public_url = ngrok.connect(8501)
print(f"Click here to open your Streamlit app: {public_url}")

